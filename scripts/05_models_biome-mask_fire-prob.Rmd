---
title: "Models of fire probability for the sagebrush biome"
author: "Martin Holdrege"
date: "`r lubridate::today()`"
output:
  html_document:
    toc: true
    toc_float:
      collapsed: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE)
```

# Dependencies 

Sourcing the script that creates a dataframe of historical
fore occurrence, as well as biotic and climate
predictors for those same grid-cells. 

```{r warning=FALSE, message=FALSE, cache = TRUE}
source("scripts/04_create_biome-mask_dataframe.R")
```

```{r warning=FALSE, message=FALSE}
source("src/general_functions.R")
source("src/fig_params.R")
source("src/modeling_functions.R")
library(randomForest)
library(tidyverse)
library(margins) # for cplot()
library(GGally) # for ggpairs()
library(gnm) # generalized non-linear models
library(pdp) # for partial dependence plots
library(splines) # for ns() (splines) inside formulas of glm()
library(gridExtra)
library(knitr)
theme_set(theme_classic())
```


# Prep data

```{r prep_data}

# converting a fire count into a factor (true if at least 1 fire occured)
occur_factor <- function(nfire){
  factor(nfire > 0, levels = c("TRUE", "FALSE"))
}
dfs_biome3 <- map(dfs_biome2, function(df) {
  out <- df %>% 
  # probability of fire in a given year
    mutate(# number of years the mtbs count data corresponds to (for binomial glm)
           # all count datasets (mtbs and ifph) are 35 years (change if updated)
           mtbs_n = 36, 
           # proportion of years with fires
           mtbs_prop = nfire_mtbs/mtbs_n,
           ifph_prop = nfire_ifph/mtbs_n,
           comb_prop = nfire_comb/mtbs_n,
           lba_prop = nfire_lba/mtbs_n
           ) %>% 
    # creating true/false occurrence cols for each datasets
    mutate(across(matches("^nfire_"), .fns = list(occur = occur_factor),
                  .names = "{.fn}_{.col}")) %>% 
    rename_with(.fn = str_replace, .cols = matches("^occur_"),
                pattern = "_nfire", replacement = "")
})

method <- names(dfs_biome3)
names(method) <- method

# Create transformed variables
dfs_biome3 <- map(dfs_biome3, function(df) {
  df %>% 
    mutate(afgAGB_sqrt = sqrt(afgAGB),
           afgAGB_ln = log(afgAGB),
           prcpPropSum_exp = exp(prcpPropSum),
           prcpPropSum_sqrt = sqrt(prcpPropSum),
           prcpPropSum_sq = prcpPropSum^2,
           MAP_sqrt = sqrt(MAP))
})
```


## training data

Using a small sample for now to make model fitting quicker

```{r train, dependson='prep_data'}
set.seed(1234)
pred_vars <- c("afgAGB", "pfgAGB", "shrCover", "MAT", "MAP", "prcpPropSum")
names(pred_vars) <- pred_vars
# predictor vars are the same in both dfs
df_pred <- dfs_biome3[[1]][, pred_vars]
n = 500000
row_nums <- 1:nrow(dfs_biome3[[1]])
rows_train <- sample(row_nums, size = n, replace = FALSE)

# rows for test dataset
rows_test <- sample(row_nums[!row_nums %in% rows_train], size = 40000, replace = FALSE)

# selecting rows this was so both dataframes in list have same rows
# and differences in models will only be b/ of differences in response
rows_train <- 1:nrow(dfs_biome3[[1]])
dfs_train <- map(dfs_biome3, function(df) as.data.frame(df[rows_train, ]))
dfs_test <- map(dfs_biome3, function(df) as.data.frame(df[rows_test, ]))

# all variables (transformed or not, that could be predictor vars)
all_pred_vars <- names(dfs_biome3[[1]]) %>% 
  str_subset(pattern = paste0("(", 
                              paste0(pred_vars, collapse = ")|("), 
                              ")")
             )
train_pred <- dfs_train[[1]][, all_pred_vars]
test_pred <- dfs_test[[1]][, all_pred_vars]
```

# Exploratory figs & summary values


```{r}

create_summary <- function(df) {
  df %>% 
    pivot_longer(cols = everything(),
                 names_to = 'variable') %>% 
    group_by(variable) %>% 
    summarise(across(value, .fns = list(mean = mean, min = min, 
                                        median = median, max = max))) %>% 
    mutate(across(where(is.numeric), round, 4))
}

df_pred %>% 
  create_summary() %>% 
  knitr::kable(caption = 'summaries of predictor variables')


response_summary <- map(dfs_biome3, function(df) {
  df %>% 
    dplyr::select(-all_of(pred_vars), -matches("^occur_")) %>% 
    create_summary()
})

kable(response_summary$paint, 
      caption = 'summaries of response variables, calculated using paint  <- ')

kable(response_summary$reduceToImage, 
      caption = 'summaries of response variables, calculated using reduceToImage method')

```

## Plot predictor vars against each other

```{r}
ggpairs(train_pred %>% select(-matches("_")),
        lower = list(continuous = GGally::wrap("points", alpha = 0.1,    size=0.2)))
```

## transformed pred vars

```{r}
"~ poly(afgAGB,2) + poly(pfgAGB,2) + I(shrCover^2) + exp(MAT) + poly(MAP,2) + exp(prcpPropSum)"

train_pred_trans <- train_pred %>% 
  mutate(afgAGB_sq = afgAGB^2,
         pfgAGB_sq = pfgAGB^2,
         MAT_exp = exp(MAT),
         MAP_sq = MAP^2,
         prcpPropSum_exp = exp(prcpPropSum))

train_pred_trans[, c("afgAGB_sq", "pfgAGB_sq", "MAT", "MAP_sq", "prcpPropSum_exp")] %>% 
  ggpairs(lower = list(continuous = GGally::wrap("points", alpha = 0.1,   
                                                 size=0.2)))
```

## boxplots-- # of fires vs predictor variables

```{r fig.height=9, fig.width=8, cache = TRUE, dependson='prep_data'}

# vectors of names of response variables
vars_nfire <- names(dfs_biome3[[1]]) %>% 
  str_subset("^nfire_")

vars_occur <- names(dfs_biome3[[1]]) %>% 
  str_subset("^occur_")

names(vars_occur) <- str_replace(vars_occur, "occur_", "")

vars_prop <- str_replace(vars_occur, "occur_", "") %>% 
  paste0(., "_prop")

names(vars_prop) <- names(vars_occur)

# function to pivot dataframe into longer format
# this function in defined here b/ it relies on pred_vars being in the
# global environment
predvars2long <- function(df, response_vars) {
  df[, c(pred_vars, response_vars)] %>% 
    pivot_longer(cols = all_of(pred_vars))
}

# longformat dataframes for making boxplots
dfs_biome_long <- map(dfs_biome3, function(df) {
  # for some reason select() was giving me problems
  predvars2long(df, response_vars = c(vars_nfire, vars_prop)) %>% 
    mutate(across(all_of(vars_nfire), factor))
})

fire_box <- function(xvar, df, method) {
  ggplot(df, aes_string(x= xvar, y = 'value')) +
    geom_boxplot() +
    facet_wrap(~name, scales = 'free_y') +
    labs(subtitle = paste0(xvar, " (", method, " method)"))
}

map2(dfs_biome_long, names(dfs_biome_long), function(df, method) {
  map(vars_nfire, fire_box, df = df, method = method)
})

  
```

## Dotplots: deciles vs fire probability

First calculating mean of response variables (proportion of years with fires) 
for each decile of each predictor
variable. 

Next plotting decile vs fire probability. Dotplots made for each predictor
variable and response variable (as well method by which response variable
was calculated)

```{r}

dfs_deciles1 <- map(dfs_biome_long, longdf2deciles, response_vars = vars_prop)
# df <- dfs_deciles1[[1]]
# yvar = vars_prop[[1]]

map2(dfs_deciles1, names(dfs_deciles1), function(df, method) {
  map(vars_prop, decile_dotplot, df = df, method = method,
      ylab = "mean observed fire probability (nfires/nyears)")
})

```


## Histograms of response vars

Histograms for all fire variables, includes all grid cells from sagebrush biome,
showing fire probability (nfires/nyears)

```{r message = FALSE, warning = FALSE}

dfs_prop_long <- map(dfs_biome3, function(df) {
  df %>% 
    select(matches("_prop$")) %>% 
    pivot_longer(cols = everything(),
                 names_to = "variable",
                 values_to = 'value') %>% 
    mutate(probability = value*100)
})

map(method, function(x) {
  ggplot(dfs_prop_long[[x]], aes(probability)) +
  geom_histogram(breaks = seq(-1, 15)) +
  facet_wrap(~variable, scales = "free_y") +
  labs(x = lab_fireProbPerc,
       caption = paste(x, "method used")) +
  coord_cartesian(xlim = c(-0.1, 15))
})

```

## Plot response variables against each other

```{r}
map(method, function(x) {
  ggpairs(dfs_train[[x]] , title =  paste0('relationships between response variables (',
                           x,  " method used)"),
        columns = vars_nfire,
        lower = list(continuous = GGally::wrap("points", alpha = 0.1, size=0.2)))
})

```

# Random forest


## Fit Model

```{r fit_rf, dependson='train'}
nodesize <-  50 # minimum size of terminal nodes in trees

# fire occurence (0/1) in MTBS data, over 35 years
forms_occur <-  map(paste(vars_occur, ' ~', paste(pred_vars, collapse = "+")),
                    as.formula)

names(forms_occur) <- names(vars_occur)

# fitting random forests to dfs of response variables created with both methods
rf_mods1 <- map(method, function(x) {
  # fitting rfs for each formula 
  map(forms_occur, randomForest, ntree = 100, data = dfs_train[[x]],
               nodesize = nodesize)
})
rf_mods2 <- flatten_rename(rf_mods1)

```

## Variable importance

```{r results='hide', fig.keep='all'}

par(mfrow = c(2, 2))
map2(rf_mods2, names(rf_mods2), function(x, y) {
  print(varImpPlot(x = x, main = y))
})

```

## Partial dependence plots

The output is transformed to yearly fire probability. Rugs on plots show
the percentiles of the predictor variable

```{r fig.height=5, fig.width = 8, cache = TRUE, dependson='train'}

pdp_all_rf_mods(mod_list = rf_mods2, df_train = train_pred)

```


## Examine Model fit

The strongly bi-modal histogram suggests this model is overfitting (i.e.
 probabilities close to 1 and 0)

```{r}
mod <- rf_mods2$paint_mtbs
y <- predict(mod, test_pred, type = "prob")
hist(calc_yearly_prob(y), main = "Predicted probabilities (per year)")
```

## transforming predictor variables

### Fit Model

```{r}
pred_vars2 <- c("afgAGB_sqrt", "pfgAGB", "shrCover", "MAP", "MAT", 
                "prcpPropSum_sqrt")

# fire occurence (0/1) in MTBS data, over 35 years
forms_occur2 <-  map(paste(vars_occur, ' ~', paste(pred_vars2, collapse = "+")),
                    as.formula)

names(forms_occur2) <- str_replace(vars_occur, "occur_", "")
# fitting random forests to dfs of response variables created with both methods
rf_mods3 <- map(method, function(x) {
  # fitting rfs for each formula 
  map(forms_occur2, randomForest, ntree = 100, data = dfs_train[[x]],
               nodesize = nodesize)
}) %>% 
  flatten_rename()

```


### Partial dependence plots

The output is transformed to yearly fire probability. Rugs on plots show
the percentiles of the predictor variable

```{r fig.height=5, fig.width = 8, cache = TRUE, dependson='fit_rf'}

pdp_all_rf_mods(mod_list = rf_mods3[1], df_train = train_pred)

```

# GLMs (all linear terms)


## fitting models

### fitting various transforms

Creating formulas where each variable on its own is transformed numerous ways
(including formula to fit spline), all other variables are left alone,
that repeated for each variable. So have models with 1 variable transformed,
2 transformed, etc. 

see documentation for glms_iterate_transforms, in the modelling_functions.R
script

```{r iterate_transform, warning = FALSE, dependson='train'}
mods_glm_mtbs1 <- glms_iterate_transforms(
  preds = pred_vars, 
  df = dfs_train$paint,
  response_var = "mtbs_prop", 
  delta_aic = 4)

# not including the last element of the list which is final_formula
mods_glm_mtbs2 <- mods_glm_mtbs1[-length(mods_glm_mtbs1)]

map_dfc(mods_glm_mtbs2, ~ names(.$aic[1:5])) %>% 
  kable(caption = "5 best transformations at each step")
best_aic_by_step <- map_dbl(mods_glm_mtbs2, ~.$aic[1])

best_aic_by_step <- c(step0 = mods_glm_mtbs1$step1$aic[['convert_none']], 
                      best_aic_by_step)
# AIC improvement by step
diff(best_aic_by_step)
plot(y = best_aic_by_step, 
     x = 1:length(best_aic_by_step) - 1,
     ylab = "AIC",
     xlab = "Number of variables transformed")

```

Best transformation each step.

```{r}
var_transformed <- map(mods_glm_mtbs2, function(x) x$var_transformed)
var_transformed
```


### same model for all response variables

Response variables are the proportion of years in which fires occurred.
Using best model formula selected in the previous step

```{r fit_glm1, dependson='iterate_transform'}



#best_form <- "~ poly(afgAGB,2)+ I(afgAGB^2):MAT + I(afgAGB^2):prcpPropSum +  poly(pfgAGB,2) + shrCover + MAT:I(MAP^2) + poly(MAP,2) + prcpPropSum*MAT + I(pfgAGB^2):prcpPropSum"

best_form <- "~ poly(afgAGB,2)+ I(afgAGB^2):prcpPropSum +  poly(pfgAGB,2) + shrCover  + poly(MAP,2)  + I(pfgAGB^2):prcpPropSum + MAT"

best_form <- "~ poly(afgAGB,2)+ I(afgAGB^2):prcpPropSum +  poly(pfgAGB,2) + shrCover + MAT:I(MAP^2) + poly(MAP,2) + I(pfgAGB^2):prcpPropSum"

best_form <- "~ poly(afgAGB,2)+ I(afgAGB^2):prcpPropSum +  poly(pfgAGB,2) + shrCover + MAT:I(MAP^2) + poly(MAP,2) + I(pfgAGB^2):prcpPropSum + prcpPropSum"

forms_glm1 <-  map(paste(vars_prop, best_form), as.formula)

best_form <- mods_glm_mtbs1$final_formula %>% 
  str_replace(".+(?=~)", "") # remove everything before ~ (i.e. response var)
best_form <- "~ poly(afgAGB,2) + poly(pfgAGB,2) + shrCover + MAT + poly(MAP,2) + prcpPropSum"
names(forms_glm1) <- names(vars_occur)
mod_glm1 <- map(method, function(x) {
  # fitting glms for each formula 
  map(forms_glm1, function(form) {
    glm(form, data = dfs_train[[x]], family = 'binomial', weights = mtbs_n)
  })
}) 
AIC(mod_glm1$paint$mtbs)


mods_glm_mtbs1$step4$aic[1]
mod_glm1_flat <- flatten_rename(mod_glm1)
summary(mod_glm1_flat$paint_mtbs)

```


## partial dependence & VIP

```{r, warning = FALSE, fig.width = 8, fig.height=8, cache = TRUE, dependson='fit_glm1'}
# vip::vip(bin_glm1) # variable importance
vip_plots1 <- map2(mod_glm1_flat, names(mod_glm1_flat), function(mod, name) {
   out <- vip::vip(mod) +
    labs(subtitle = name)
})
marrangeGrob(vip_plots1, ncol = 3, nrow = 3)
map(mod_glm1_flat[1], pdp_all_vars, mod_vars = pred_vars, ylab = 'probability',
              train = test_pred)
```


## observed vs. predicted

Predicting on different rows than models fit using

```{r}
pred_glm1 <- map2(mod_glm1, dfs_test, function(mods, df) {
  df_out <- df
  for(var in names(vars_prop)) {
    mod <- mods[[var]]
    
    response_name <- paste0(vars_prop[[var]], "_pred")
    df_out[[response_name]] <- predict(mod, df, type = 'response')
  }
  df_out
})

dfs_test_warm <- map(dfs_test, function(df) mutate(df, MAT = MAT + 5))

pred_glm1_warm <- map2(mod_glm1, dfs_test_warm, function(mods, df) {
  df_out <- df
  for(var in names(vars_prop)) {
    mod <- mods[[var]]
    
    response_name <- paste0(vars_prop[[var]], "_pred")
    df_out[[response_name]] <- predict(mod, df, type = 'response')
  }
  df_out
})
```

```{r message = FALSE}

# long format so can have observed and predicted columns
pred_glm1_long <- map(pred_glm1, function(df) { 
  df %>% 
    select(matches("_prop")) %>% 
    mutate(row = 1:n()) %>% 
    pivot_longer(cols = -row) %>% 
    mutate(data_source = str_extract(name, "^[a-z]+"),
           type = ifelse(str_detect(name, "prop_pred$"), 'predicted', 
                         'observed')) %>% 
    select(-name) %>% 
    pivot_wider(id_cols = c('row', 'data_source'), 
                names_from = 'type',
                values_from = 'value') %>% 
    select(-row)
})

# observed vs predicted ggplots
g <- ggplot(pred_glm1_long[[1]] %>% filter(observed <= 0.1), 
            aes(y = predicted)) +
  facet_wrap(~data_source) +
  labs(subtitle = 'observed and predicted fire probabilities',
       y = "predicted probability")

g +
  geom_boxplot(aes(x = as.factor(as.numeric(as.factor(observed)) - 1)))+
  labs(x = "number of observed fires")

g +
  geom_jitter(aes(x = observed), width = 0.005, alpha = 0.1) +
  geom_smooth(aes(x = observed), method = 'lm') +
  geom_abline(slope = 1) 

```

### Deciles

Binning predictor variables into deciles and looking at the mean
predicted probability for each decile.

```{r}
vars_prop_pred <- paste0(vars_prop, "_pred")

pred_glm1_deciles <- map(pred_glm1, function(df) {
  response_vars <- c(vars_prop, vars_prop_pred)
  # longformat df
  long_df <- predvars2long(df, response_vars = response_vars)
  # mean of deciles
  out <- longdf2deciles(long_df, response_vars = response_vars)
  out
})

pred_glm1_deciles_warm <- map(pred_glm1_warm, function(df) {
  response_vars <- c(vars_prop, vars_prop_pred)
  # longformat df
  long_df <- predvars2long(df, response_vars = response_vars)
  # mean of deciles
  out <- longdf2deciles(long_df, response_vars = response_vars)
  out
})

map2(pred_glm1_deciles, names(pred_glm1_deciles), function(df, method) {
  map(vars_prop, decile_dotplot, df = df, method = method, 
      add_predicted = TRUE)
})

# tryng
map2(pred_glm1_deciles_warm, names(pred_glm1_deciles_warm), function(df, method) {
  map(vars_prop, decile_dotplot, df = df, method = method, 
      add_predicted = TRUE)
})

```

Plot observed vs predicted values for the deciles

```{r}
# long format, so have columns of predicted and observed
# and can facet by response variable
dfs_obs_v_pred <- map(pred_glm1_deciles, function(df) {
  df %>% 
    select(matches("_prop")) %>% 
    mutate(id = 1:nrow(.)) %>% 
    pivot_longer(cols = matches("_prop")) %>% 
    mutate(type = ifelse(str_detect(name, "_pred$"),
                         "predicted", "observed"),
           variable = str_extract(name, "^[a-z]+")) %>% 
    pivot_wider(id_cols = c(id, variable), names_from = 'type')
})     

map2(dfs_obs_v_pred, names(dfs_obs_v_pred), function(df, method) {
  ggplot(df, aes(observed, predicted)) +
    geom_point() +
    facet_wrap(~variable) +
    geom_abline(slope = 1) +
    labs(title = paste(method, "method"),
         subtitle = "fire probability averaged for each decile of each predictor variable",
         caption = "each panel shows observed and predicted values
         of annual fire probability, for a given fire dataset")
})

```


## GLMS with splines