---
title: "Cross validation using environmental blocking"
subtitle: "Based on before/after fire resampled data"
author: "Martin Holdrege"
date: "`r lubridate::today()`"
output:
  html_document:
    toc: true
    toc_float:
      collapsed: false
---

The goal here is to split the data into multiple training/testing
blocks based on clustering grid-cells by climate.

# Dependencies

```{r, message = FALSE, warning = FALSE}
source("scripts/04_create_biome-mask_dataframe_byNFire.R")
source("src/resample_functions.R")
source("src/modeling_functions.R")
source("src/basemaps.R")
source("src/fig_params.R")
library(blockCV) # for creating environmental blocks
library(sf)
library(knitr)

```

## Read in data

Read in model object (for the formula)

```{r}
mods1 <- readRDS("models/glm_binomial_models_byNFire_v2_bin20_cwf.RDS")
```

Reading in the data again here because below the data needs to be 
a raster object not a terra object, and the conversion between the two
was not properly working

```{r}

seasons <- c('Yearly', 'Summer') # not using spring at the moment

# using the data starting in 1986 so that it matches the rap data
# that we're using
clim_paths <- paste0("data_processed/daymet/daymet_clim",  seasons,
                     "Avg_1986-2019_1000m", maskString, "v1.tif")

names(clim_paths) <- seasons

r_clim1 <- map(clim_paths, raster::brick) # list of rasters
```


# Determine Blocks


Combine climate data into a single raster for use in blockCV::envBlock(),
and create an sf object of fake datapoints so that function will work. 

```{r}

r_clim2 <- raster::stack(r_clim1$Yearly[[c("prcp", "tavg")]],
             r_clim1$Summer[['prcpProp']]) %>% 
  raster::setMinMax() # if this isn't set envBlock won't work

names(r_clim2) <- c("MAP", "MAT", "prcpPropSum")


n <- ncell(r_clim2)
cell_coords <- xyFromCell(r_clim2[[1]], 1:n) %>% 
  as.data.frame() %>% 
  mutate(
    value = as.numeric(values(r_clim2[[1]])),
    cell_num = 1:n,
    # thi is just a dummy variable to make 
    #  envBlock() run
    dummy_col = sample(c(0,1), n, replace = TRUE)) %>% 
  filter(!is.na(value)) %>% 
  dplyr::select(-value)


# sf object of the center of sagebrush biome grid points
cells_sf1 <- st_as_sf(cell_coords, coords = c("x", "y"),
                      crs = sf::st_crs(r_clim2))

k <- 5
fold_name <- paste0('fold', 1:k)

set.seed(124) # envBlock uses kmeans which is affected by the seed

eb1 <- envBlock(rasterLayer = r_clim2,
               speciesData = cells_sf1,
               species = "dummy_col", # name of the column with response
               k = k,
               standardization = "normal",
               rasterBlock = TRUE)

# checking that size of all test datasets sums to the 
# number of grid cells in the original dataset
stopifnot(length(unique(df_byNFire2$cell_num)) 
          == sum(eb1$records$test_0 +eb1$records$test_1))
```

size of folds

```{r}
fold_size <- eb1$records %>% 
  mutate(fold_size = test_0 + test_1,
         fold = 1:nrow(.)) %>% 
  select(fold_size, fold) 

kable(fold_size, caption = "Number of pixels per fold")
```



# Prepare Data

## Resample

First, bin the data.

```{r}
pred_vars <- c("afgAGB", "pfgAGB", "MAT", "MAP", "prcpPropSum")
names(pred_vars) <- pred_vars
response_vars <- c("cwf_prop", "cwf_prop_pred")

bins <- 20

df_binned1 <- bin_df(df_byNFire2, cols = pred_vars, n_categories = bins)

df_resampled1 <- resample_bins(df_binned1)
```


## Split into train/test

```{r}
cell_nums <- unique(df_byNFire2$cell_num)

test_cell_endices <- map(eb1$folds, function(x) x[[2]])

# show be as many unique values in all the test sets as
# there are gridcells in the original dataset
stopifnot(length(unique(unlist(test_cell_endices))) == 
            length(unique(df_byNFire2$cell_num)))

# shouldn't be duplicates in the test dataset endices
stopifnot(sum(duplicated(unlist(test_cell_endices))) == 0)


test_cell_nums <- map(test_cell_endices, function(x) {
  # the first element of the sub list contains the endices
  # of the training data set, the second the endices for the test set
  stopifnot(max(x) <= length(cell_nums))
  cell_nums[x] 
})

stopifnot(
  sort(unique(unlist(test_cell_nums))) == 
    sort(unique(df_byNFire2$cell_num))
)

df_test_cell_nums <- map2_dfr(test_cell_nums, fold_name, function(x, y) {
  tibble(cell_num = x,
         fold = y)
})

names(test_cell_nums) <- fold_name

dfs_test1 <- map(test_cell_nums, function(x) {
  df_resampled1[df_resampled1$cell_num %in% x, ] 
})

dfs_train1 <- map(test_cell_nums, function(x) {
  df_resampled1[!df_resampled1$cell_num %in% x, ] 
})

```

# Describe folds

```{r}
cols_fold <- RColorBrewer::brewer.pal(k, 'RdYlBu')
names(cols_fold) <- fold_name
r_folds1 <- r_clim2[[1]]
r_folds1[!is.na(r_folds1)] <- eb1$foldID

# the base and bbox objects come from src/basemaps.R
base +
  tm_shape(r_folds1, bbox = bbox) +
  tm_raster(palette = cols_fold,
            as.count = TRUE,
            title = "Fold") +
  tm_layout(main.title = "Folds (environmental blocks) used for cross validation")

```

Summarizing fire occurrence by fold

```{r}
df_byNFire2_fold <- df_byNFire2 %>% 
  left_join(df_test_cell_nums, by = 'cell_num')
  
df_byNFire2_fold %>% 
  group_by(fold) %>% 
  summarise(observed_fire_probability = weighted.mean(cwf_prop, w = numYrs)) %>% 
  select(fold, observed_fire_probability) %>% 
  kable(caption = "Mean observed fire probability by fold")
```

Climate by fold

```{r}
df_byNFire2_fold %>% 
  filter(!duplicated(cell_num)) %>% 
  group_by(fold) %>% 
  mutate(MAT = MAT - 273.15) %>% 
  summarise(across(c(MAT, MAP, prcpPropSum),
                .fns = list(mean = mean,min = min, max =  max, sd = sd))) %>% 
  pivot_longer(cols = -fold,
               names_to = c("variable", "summary_stat"),
               names_sep = "_") %>% 
  pivot_wider(names_from = 'variable') %>% 
  mutate(across(matches("MAT|MAP"), round, digits = 1),
       across(matches("prcpPropSum"), round, digits = 3)) %>% 
  arrange(summary_stat) %>% 
  kable(caption = "Summary of climate variables by fold")

```


# Fit models

All models have the same formula. But are fit to data where one
block of data is held out. 

```{r}
form1 <- mods1$paint_cwf$formula

mods_train1 <- map(dfs_train1, function(df) {
  glm(form1, family = 'binomial', data = df,
      weights = numYrs)
})


# predictions on the test data set
dfs_test2 <- map2(mods_train1, dfs_test1, function(mod, df) {
  df$cwf_prop_pred <- predict(mod, newdata = df, type = 'response')
  df
})

```


## PDP

These aren't real partial dependence plots--for the sake of computational
efficiency, I'm predicting across the range of a given predictor
variable, with other variables held at their mean. 


```{r}

mods_train2 <- c(mods_train1, list('biome-wide' = mods1$paint_cwf))
preds_avg <- map_dfr(mods_train2, predict_across_avg, pred_vars = pred_vars,
                   df = df_resampled1[pred_vars],
                   .id = 'fold')

ggplot(preds_avg, aes(value, yhat, color = fold)) +
  geom_line() +
  facet_wrap(~pred_var, scales = 'free') +
  labs(x = "Predictor variable",
       y = "Predicted fire probability",
       subtitle = "'Pseudo' partial dependence plots for different training datasets",
       caption = "Each model was fit to data where one environmental block was was left out. 
       Predictions are across the whole range of a given predictor variable, and for
       the biome-wide average of all other predictor variables") +
  scale_color_manual(values = c(cols_fold, 'biome-wide' = 'black'), 
                     name = "Fold left out")

```


## Observed vs predicted

### Deciles

```{r}

pred_test_deciles1 <- map(dfs_test2, predvars2deciles, pred_vars = pred_vars,
                 response_vars = response_vars)

map2(pred_test_deciles1, names(pred_test_deciles1), function(df, fold) {
  decile_dotplot_pq(df = df) +
    labs(subtitle = paste0("Predictions on ", fold, 
                           " (model fit to other folds)"))
})
```


### deciles filtered

```{r}
pred_test_deciles_filt <- map(dfs_test2, predvars2deciles, pred_vars = pred_vars,
                 response_vars = response_vars,
                 filter_var = TRUE)

map2(pred_test_deciles_filt, names(pred_test_deciles_filt), function(df, fold) {
  decile_dotplot_filtered(yvar = response_vars[1], df = df, add_smooth = TRUE,
                 subtitle = paste0("Predictions on ", fold, 
                                   " (model fit to other all other folds)"))
})
```

# session info

Hash of current commit (i.e. to ID the version of the code used)

```{r}
system("git rev-parse HEAD", intern=TRUE)
```

Packages etc.

```{r}
sessionInfo()

```











