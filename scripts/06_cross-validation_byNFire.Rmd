---
title: "Cross validating model"
subtitle: "Based on fefore/after fire resampleddata"
author: "Martin Holdrege"
date: "`r lubridate::today()`"
output:
  html_document:
    toc: true
    toc_float:
      collapsed: false
---

The goal here is to split the sagebrush biome into 4 quadrants. Leave
one quadrant out and fit the glm to the others, then predict on
that 4th quadrant and create the observed/predicted 'decile' plot
for that test data set.

# Dependencies

User defined parameters:

```{r}
# setting to TRUE causes the data set to
# be run on a small sample of the data (i.e. for a quicker run of the code)
test_run <- FALSE
```


```{r}
source("scripts/04_create_biome-mask_dataframe_byNFire.R")
source("src/resample_functions.R")
source("src/cv_functions.R")
source("src/modeling_functions.R")

```

Read in model object (for the formula)

```{r}
mods1 <- readRDS("models/glm_binomial_models_byNFire_v1_bin20_cwf_.RDS")
```


# Find Quadrants

Here want to create a point that forms a '+' through the middle of the sagebrush
biome to create equal sized quadrants. Here figuring out the location of
of the center of the '+'. 

```{r}
set.seed(1234)
r_biome0 <- rast_rap1[[1]]

r_biome0[is.finite(r_biome0)] <- 1
names(r_biome0) <- "biome_mask"
# set to FALSE if don't want to rerun this slow code,
# and just use the value determine last time it was run
if(!test_run) {
  # first approximation of the geographic center of the biome
  center1 <- terra::aggregate(r_biome0, fact = 70, na.rm = TRUE) %>% 
    as.polygons() %>% 
    centroids() %>% 
    geom() %>% 
    as.data.frame()
  
  best_center <- best_quadrant_center(r_biome0, x = center1$x,
                                      y = center1$y)
} else {
  best_center <- c('x' = -112.41438,
                   'y' = 42.12961 )
}

best_center
```


```{r message=FALSE, warning=FALSE, error = TRUE}
r_quads <- create_quadrants(r_biome0, x = best_center['x'],
                                y = best_center['y'])
# plot(r_quads)
plot(r_biome0*r_quads,
     main = "The quadrants used for cross validation")
```

# Prepare Data

## Resample

First, bin the data.

```{r}
pred_vars <- c("afgAGB", "pfgAGB", "MAT", "MAP", "prcpPropSum")
names(pred_vars) <- pred_vars
response_vars <- c("cwf_prop", "cwf_prop_pred")

bins <- 20

df_binned1 <- bin_df(df_byNFire2, cols = pred_vars, n_categories = bins)

df_resampled1 <- resample_bins(df_binned1)
```

## Training/test df's

Based on the cell numbers defining each row as quad 1, 2, 3 or 4. 

```{r}
df_quads <- get_values("biome_mask", r_quads) %>% 
  rename(quad = value) %>% 
  select(-lyr)

df_resampled2 <- df_resampled1 %>% 
  left_join(df_quads, by = "cell_num")

if(test_run) {
  df_resampled2 <- df_resampled2 %>% 
    slice_sample(n =10000)
}

# shouldn't have any NAs after the join
stopifnot(!is.na(df_resampled2$quad))
```


```{r}
quad_nums <- 1:4
quad_names <- paste0('quad', quad_nums)
names(quad_nums) <- quad_names
```

Training data sets contain all rows except those for one quadrant, the
test df contains just the rows for that quadrant.

```{r}
dfs_test1 <- map(quad_nums, function(x) {
  df_resampled2 %>% 
    filter(quad == x)
})

dfs_train1 <- map(quad_nums, function(x) {
  df_resampled2 %>% 
    filter(quad != x)
})

```


# Fit models

```{r}

form1 <- mods1$paint_cwf$formula

mods_train1 <- map(dfs_train1, function(df) {
  glm(form1, family = 'binomial', data = df,
      weights = numYrs)
})

# this is just for exploration--fitting models seperately to 
# each quadrant
mods_test1 <- map(dfs_test1, function(df) {
  glm(form1, family = 'binomial', data = df,
      weights = numYrs)
})

# predictions onb the test data set
dfs_test2 <- map2(mods_train1, dfs_test1, function(mod, df) {
  df$cwf_prop_pred <- predict(mod, newdata = df, type = 'response')
  df
})

```

## PDP

These aren't real partial dependence plots--for the sake of computational
efficiency, I'm predicting across the range of of a given predictor
variable, with other variables held at their mean. 


```{r}

preds_avg <- map_dfr(mods_train1, predict_across_avg, pred_vars = pred_vars,
                   df = df_resampled2[pred_vars],
                   .id = 'quad')

ggplot(preds_avg, aes(value, yhat, color = quad)) +
  geom_line() +
  facet_wrap(~pred_var, scales = 'free') +
  labs(x = "Predictor variable",
       y = "Predicted fire probability",
       subtitle = "'Pseudo' partial dependence plots for different training datasets",
       caption = "Each model was fit to data where one of the quadrants was left out. 
       Predictions are across the whole range of a given predictor variable, and for
       the biome-wide average of all other predictor variables") +
  guides(color = guide_legend(title = "Quadrant left out"))


```

Here are more 'pseudo' pdp plots. In this case the models were
fit just one quadrants


```{r}

preds_test_avg <- map_dfr(mods_test1, predict_across_avg, pred_vars = pred_vars,
                   df = df_resampled2[pred_vars],
                   .id = 'quad')

ggplot(preds_test_avg, aes(value, yhat, color = quad)) +
  geom_line() +
  facet_wrap(~pred_var, scales = 'free') +
  labs(x = "Predictor variable",
       y = "Predicted fire probability",
       subtitle = "'Pseudo' partial dependence plots for models fit to one quadrant",
       caption = "Each model was fit to data for one quadrant. 
       Predictions are across the whole range of a given predictor variable, and for
       the biome-wide average of all other predictor variables") +
  guides(color = guide_legend(title = "Quadrant model fit to"))


```


## Observed vs. predicted

### Deciles

```{r}

pred_test_deciles1 <- map(dfs_test2, predvars2deciles, pred_vars = pred_vars,
                 response_vars = response_vars)

map2(pred_test_deciles1, names(pred_test_deciles1), function(df, quad) {
  decile_dotplot(yvar = response_vars[1], df = df, add_predicted = TRUE,
                 subtitle = paste0("Predictions on ", quad, 
                                   " (model fit to other quadrants)"))
})
```


### deciles filtered

```{r}
pred_test_deciles_filt <- map(dfs_test2, predvars2deciles, pred_vars = pred_vars,
                 response_vars = response_vars,
                 filter_var = TRUE)

map2(pred_test_deciles_filt, names(pred_test_deciles_filt), function(df, quad) {
  decile_dotplot_filtered(yvar = response_vars[1], df = df, add_smooth = TRUE,
                 subtitle = paste0("Predictions on ", quad, 
                                   " (model fit to other quadrants)"))
})
```

# session info

Hash of current commit (i.e. to ID the version of the code used)

```{r}
system("git rev-parse HEAD", intern=TRUE)
```

Packages etc.

```{r}
sessionInfo()

```